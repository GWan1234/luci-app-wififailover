#!/usr/bin/lua
-- Файл: files/usr/bin/wififailover-daemon
-- WiFi Failover Daemon для LEDE 17.01.7

local uci = require "uci"
local socket = require "socket"
local utils = require "wififailover.utils"

-- Глобальные переменные
local daemon = {}
daemon.running = false
daemon.failure_count = 0
daemon.current_network_index = 1
daemon.last_check = 0
daemon.pid_file = "/var/run/wififailover.pid"

-- Инициализация UCI курсора
local cursor = uci.cursor()

-- Запись PID файла
function daemon.write_pid()
    local pid = unistd and unistd.getpid() or "unknown"
    local file = io.open(daemon.pid_file, "w")
    if file then
        file:write(tostring(pid) .. "\n")
        file:close()
        utils.log("DEBUG", "PID file created: " .. daemon.pid_file)
    else
        utils.log("ERROR", "Failed to create PID file")
    end
end

-- Удаление PID файла
function daemon.remove_pid()
    os.remove(daemon.pid_file)
    utils.log("DEBUG", "PID file removed")
end

-- Обработка сигналов завершения
function daemon.signal_handler(sig)
    utils.log("INFO", "Received signal: " .. tostring(sig))
    daemon.running = false
end

-- Проверка, запущен ли уже демон
function daemon.is_already_running()
    local file = io.open(daemon.pid_file, "r")
    if not file then
        return false
    end
    
    local pid = file:read("*line")
    file:close()
    
    if pid then
        -- Проверяем, существует ли процесс
        local check_cmd = string.format("kill -0 %s 2>/dev/null", pid)
        local result = os.execute(check_cmd)
        return (result == 0 or result == true)
    end
    
    return false
end

-- Получение следующей сети по приоритету
function daemon.get_next_network(networks, current_index)
    if #networks == 0 then
        return nil, 1
    end
    
    local next_index = current_index + 1
    if next_index > #networks then
        next_index = 1  -- Переход к первой сети (круговое переключение)
    end
    
    return networks[next_index], next_index
end

-- Ожидание подключения к сети
function daemon.wait_for_connection(ssid, timeout)
    local start_time = os.time()
    timeout = timeout or 60
    
    utils.log("INFO", string.format("Waiting for connection to %s (timeout: %ds)", ssid, timeout))
    
    while (os.time() - start_time) < timeout do
        socket.sleep(2)
        
        local current_ssid = utils.get_current_wifi()
        if current_ssid == ssid then
            utils.log("INFO", "Successfully connected to: " .. ssid)
            return true
        end
    end
    
    utils.log("WARNING", "Connection timeout for: " .. ssid)
    return false
end

-- Переключение на следующую сеть
function daemon.switch_to_next_network(networks, settings)
    local next_network, next_index = daemon.get_next_network(networks, daemon.current_network_index)
    
    if not next_network then
        utils.log("ERROR", "No networks available for switching")
        return false
    end
    
    utils.log("INFO", string.format("Switching to network: %s (priority: %d)", 
              next_network.ssid, next_network.priority))
    
    -- Подключение к новой сети
    local success = utils.connect_wifi(next_network.ssid, next_network.key, next_network.security)
    if not success then
        utils.log("ERROR", "Failed to configure WiFi for: " .. next_network.ssid)
        return false
    end
    
    -- Ожидание подключения
    if daemon.wait_for_connection(next_network.ssid, settings.connection_timeout) then
        -- Обновление текущей сети
        utils.set_current_network(next_network.ssid)
        utils.update_last_connected(next_network.id)
        daemon.current_network_index = next_index
        daemon.failure_count = 0  -- Сброс счетчика ошибок
        
        utils.log("INFO", "Successfully switched to: " .. next_network.ssid)
        return true
    else
        utils.log("ERROR", "Failed to connect to: " .. next_network.ssid)
        return false
    end
end

-- Основной цикл мониторинга
function daemon.monitoring_loop()
    utils.log("INFO", "WiFi Failover daemon started")
    
    while daemon.running do
        local current_time = os.time()
        local settings = utils.get_settings()
        
        -- Проверка интервала
        if (current_time - daemon.last_check) < settings.check_interval then
            socket.sleep(1)
            goto continue
        end
        
        daemon.last_check = current_time
        
        -- Проверка, включен ли сервис
        if settings.enabled ~= "1" then
            utils.log("DEBUG", "Service disabled, sleeping...")
            socket.sleep(settings.check_interval)
            goto continue
        end
        
        -- Проверка автопереключения
        if settings.auto_switch ~= "1" then
            utils.log("DEBUG", "Auto-switch disabled, sleeping...")
            socket.sleep(settings.check_interval)
            goto continue
        end
        
        -- Получение списка сетей
        local networks = utils.get_networks()
        if #networks == 0 then
            utils.log("WARNING", "No networks configured")
            socket.sleep(settings.check_interval)
            goto continue
        end
        
        -- Проверка интернет-соединения
        local internet_ok = utils.check_internet(settings.ping_host)
        
        if internet_ok then
            -- Интернет работает
            if daemon.failure_count > 0 then
                utils.log("INFO", "Internet connection restored")
                daemon.failure_count = 0
            end
            
            -- Проверка на возможность переключения на более приоритетную сеть
            local current_ssid = utils.get_current_wifi()
            if current_ssid then
                local available_networks = utils.scan_wifi()
                
                -- Поиск более приоритетной сети
                for i, network in ipairs(networks) do
                    if available_networks[network.ssid] and network.ssid ~= current_ssid then
                        -- Найдена более приоритетная сеть
                        utils.log("INFO", string.format("Found higher priority network: %s", network.ssid))
                        
                        if daemon.switch_to_next_network({network}, settings) then
                            daemon.current_network_index = i
                            break
                        end
                    end
                end
            end
        else
            -- Интернет не работает
            daemon.failure_count = daemon.failure_count + 1
            utils.log("WARNING", string.format("Internet check failed (%d/%d)", 
                      daemon.failure_count, settings.max_failures))
            
            if daemon.failure_count >= settings.max_failures then
                utils.log("ERROR", "Max failures reached, switching network")
                
                if daemon.switch_to_next_network(networks, settings) then
                    utils.log("INFO", "Network switched successfully")
                else
                    utils.log("ERROR", "Failed to switch network")
                    -- Увеличиваем индекс для следующей попытки
                    daemon.current_network_index = daemon.current_network_index + 1
                    if daemon.current_network_index > #networks then
                        daemon.current_network_index = 1
                    end
                end
            end
        end
        
        ::continue::
        socket.sleep(1)
    end
    
    utils.log("INFO", "WiFi Failover daemon stopped")
end

-- Функция запуска демона
function daemon.start()
    -- Проверка на повторный запуск
    if daemon.is_already_running() then
        print("Daemon is already running")
        os.exit(1)
    end
    
    -- Запись PID
    daemon.write_pid()
    
    -- Установка обработчиков сигналов (если поддерживается)
    if signal then
        signal.signal(signal.SIGTERM, daemon.signal_handler)
        signal.signal(signal.SIGINT, daemon.signal_handler)
    end
    
    daemon.running = true
    
    -- Основной цикл
    local success, err = pcall(daemon.monitoring_loop)
    if not success then
        utils.log("ERROR", "Daemon error: " .. tostring(err))
    end
    
    -- Очистка
    daemon.remove_pid()
end

-- Функция остановки демона
function daemon.stop()
    local file = io.open(daemon.pid_file, "r")
    if not file then
        print("Daemon is not running")
        return
    end
    
    local pid = file:read("*line")
    file:close()
    
    if pid then
        local kill_cmd = string.format("kill %s", pid)
        os.execute(kill_cmd)
        print("Daemon stopped")
    else
        print("Invalid PID file")
    end
end

-- Основная функция
function main()
    local command = arg and arg[1] or ""
    
    if command == "start" then
        daemon.start()
    elseif command == "stop" then
        daemon.stop()
    elseif command == "restart" then
        daemon.stop()
        socket.sleep(2)
        daemon.start()
    else
        print("Usage: " .. arg[0] .. " {start|stop|restart}")
        os.exit(1)
    end
end

-- Запуск только если скрипт вызван напрямую
if arg and arg[0] then
    main()
end

return daemon