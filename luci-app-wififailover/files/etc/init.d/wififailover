#!/bin/sh /etc/rc.common
# Файл: files/etc/init.d/wififailover
# Init скрипт для WiFi Failover daemon (LEDE 17.01)

START=99
STOP=10

USE_PROCD=1
PROG="/usr/bin/wififailover-daemon"
PIDFILE="/var/run/wififailover.pid"

validate_section() {
    uci_validate_section wififailover settings "${1}" \
        'enabled:bool:0' \
        'ping_host:string:8.8.8.8' \
        'check_interval:uinteger:30' \
        'max_failures:uinteger:3' \
        'connection_timeout:uinteger:60' \
        'debug:bool:0' \
        'auto_switch:bool:1'
}

start_service() {
    local enabled ping_host check_interval max_failures connection_timeout debug auto_switch
    
    validate_section settings || {
        echo "Validation failed"
        return 1
    }
    
    [ "$enabled" = "1" ] || {
        echo "WiFi Failover is disabled"
        return 1
    }
    
    # Проверка зависимостей
    [ -x "$PROG" ] || {
        echo "WiFi Failover daemon not found: $PROG"
        return 1
    }
    
    # Проверка наличия Wi-Fi интерфейса
    [ -d /sys/class/net/wlan0 ] || {
        echo "WiFi interface wlan0 not found"
        return 1
    }
    
    echo "Starting WiFi Failover daemon"
    
    procd_open_instance
    procd_set_param command "$PROG" start
    procd_set_param pidfile "$PIDFILE"
    procd_set_param respawn ${respawn_threshold:-3600} ${respawn_timeout:-5} ${respawn_retry:-5}
    procd_set_param stdout 1
    procd_set_param stderr 1
    
    # Мониторинг файлов конфигурации
    procd_set_param file /etc/config/wififailover
    
    # Пользователь и группа
    procd_set_param user root
    
    # Переменные окружения
    procd_set_param env DAEMON_MODE=1
    
    procd_close_instance
}

stop_service() {
    echo "Stopping WiFi Failover daemon"
    
    # Отправка SIGTERM процессу
    [ -f "$PIDFILE" ] && {
        local pid=$(cat "$PIDFILE" 2>/dev/null)
        [ -n "$pid" ] && kill "$pid" 2>/dev/null
    }
    
    # Очистка PID файла
    rm -f "$PIDFILE"
}

restart() {
    stop
    sleep 2
    start
}

reload_service() {
    echo "Reloading WiFi Failover daemon"
    
    # Перезагрузка конфигурации без перезапуска
    [ -f "$PIDFILE" ] && {
        local pid=$(cat "$PIDFILE" 2>/dev/null)
        [ -n "$pid" ] && kill -HUP "$pid" 2>/dev/null || restart
    } || start
}

service_triggers() {
    # Триггеры для автоматической перезагрузки при изменении конфигурации
    procd_add_reload_trigger "wififailover"
    
    # Мониторинг сетевых интерфейсов
    procd_add_raw_trigger "interface.*" 2000 /etc/init.d/wififailover reload
}

status() {
    local enabled
    validate_section settings || return 1
    
    echo "WiFi Failover Service Status:"
    echo "- Enabled: $([ "$enabled" = "1" ] && echo "Yes" || echo "No")"
    
    if [ -f "$PIDFILE" ]; then
        local pid=$(cat "$PIDFILE" 2>/dev/null)
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            echo "- Daemon: Running (PID: $pid)"
        else
            echo "- Daemon: Dead (stale PID file)"
            rm -f "$PIDFILE"
        fi
    else
        echo "- Daemon: Not running"
    fi
    
    # Информация о текущей сети
    local current_ssid=$(iw dev wlan0 link 2>/dev/null | grep 'SSID' | awk '{print $2}' 2>/dev/null)
    echo "- Current WiFi: ${current_ssid:-Not connected}"
    
    # Проверка интернета
    if ping -c 1 -W 3 8.8.8.8 >/dev/null 2>&1; then
        echo "- Internet: Connected"
    else
        echo "- Internet: Disconnected"
    fi
    
    # Количество настроенных сетей
    local networks_count=$(uci show wififailover | grep -c "wififailover\..*\.ssid=" 2>/dev/null || echo "0")
    echo "- Configured networks: $networks_count"
}

# Дополнительные команды для удобства
case "$1" in
    status)
        status
        ;;
    configtest)
        echo "Testing configuration..."
        validate_section settings && echo "Configuration is valid" || echo "Configuration is invalid"
        ;;
esac